package org.allenai.pnp.semparse

import scala.collection.JavaConverters._
import scala.collection.mutable.ListBuffer

import com.jayantkrish.jklol.ccg.lambda.Type
import com.jayantkrish.jklol.ccg.lambda2.Expression2
import com.jayantkrish.jklol.ccg.lambda2.StaticAnalysis

/** Template represents an action that expands a type
  * to an expression. The expression itself may contain
  * typed "holes" to be filled by future templates. 
  * Applying a template to a semantic parser state
  * expands the current hole in the state with the template,
  * returning the next state. 
  */
sealed trait Template {
  val root: Type
  val holeIndexes: Array[Int]
  
  /** Update state by applying this template to expand the  
    * current hole.
    */
  def apply(state: SemanticParserState): SemanticParserState

  /** Returns true if the subexpression at expIndex of exp could
    * be generated by using this template.
    */
  def matches(expIndex: Int, exp: Expression2, typeMap: Map[Integer, Type]): Boolean
}

/** A function application template that rewrites a type
  * as a function type applied to one or more argument types,
  * e.g., t -> (<e,t> <e>)
  */
case class ApplicationTemplate(val root: Type, val expr: Expression2,
    val holes: List[(Int, Type, Boolean)]) extends Template {

  val holeIndexes = holes.map(_._1).toArray
  val holeTypes = holes.map(_._2).toArray 
  
  override def apply(state: SemanticParserState): SemanticParserState = {
    val holeIds = ListBuffer.empty[Int]
    for (i <- state.nextId until (state.nextId + holeIndexes.length)) {
      holeIds += i
    }

    val filled = state.unfilledHoleIds.head
    val holeScope = filled.scope
    val part = ExpressionPart(expr, holeIndexes.toArray, holeIds.toArray)
    val newHoles = holeIds.zip(holes).map(x => Hole(x._1, x._2._2, holeScope, x._2._3))
    
    state.fill(filled, part, newHoles.toList, this)
  } 

  override def matches(expIndex: Int, exp: Expression2, typeMap: Map[Integer, Type]): Boolean = {
    val subexp = exp.getSubexpression(expIndex)
    if (!subexp.isConstant) {
      val childIndexes = exp.getChildIndexes(expIndex).toList
      val exprChildIndexes = expr.getChildIndexes(0).toList
      if (childIndexes.length == exprChildIndexes.length) {
        for (i <- 0 until childIndexes.length) {
          val child = childIndexes(i)
          val exprChild = exprChildIndexes(i)
          
          if (holeIndexes.contains(exprChild)) {
            if (!typeMap(child).equals(holeTypes(holeIndexes.indexOf(exprChild)))) {
              return false
            }
          } else {
            if (!exp.getSubexpression(child).equals(expr.getSubexpression(exprChild))) {
              return false
            }
          }
        }
        true
      } else {
        false
      }
    } else {
      false
    }
  }

  override def toString(): String = {
    root + " -> " + expr
  }
}

object ApplicationTemplate {
  def fromTypes(root: Type, holeTypes: List[(Type, Boolean)]): ApplicationTemplate = {
    val varNames: ListBuffer[Expression2] = ListBuffer.empty
    val holesBuffer: ListBuffer[Int] = ListBuffer.empty
    for (i <- 1 to holeTypes.length) {
      varNames += Expression2.constant(holeTypes(i - 1)._1.toString)
      holesBuffer += i
    }

    val expr = Expression2.nested(varNames.toList.asJava)
    val holeIndexes = holesBuffer.toList
    
    val holes = holeIndexes.zip(holeTypes).map(x => (x._1, x._2._1, x._2._2))

    ApplicationTemplate(root, expr, holes)
  }
}

/** A template generating a constant, e.g., argmax:<<e,t>,t>.
  * This template is the base case of expression generation as
  * it has no holes.
  */
case class ConstantTemplate(val root: Type, val expr: Expression2) extends Template {
  val holeIndexes = Array[Int]()
  
  override def apply(state: SemanticParserState): SemanticParserState = {
    val filled = state.unfilledHoleIds.head
    val part = ExpressionPart(expr, Array.empty[Int], Array.empty[Int])
    state.fill(filled, part, List(), this)
  }

  override def matches(expIndex: Int, exp: Expression2, typeMap: Map[Integer, Type]): Boolean = {
    exp.getSubexpression(expIndex).equals(expr)
  }
  
  override def toString(): String = {
    root + " -> " + expr
  }
}

/** A template that generates a lambda expression.
  */ 
case class LambdaTemplate(val root: Type, val args: List[Type], val body: Type) extends Template {
  val holeIndexes = Array[Int](3 + args.length)
  
  override def apply(state: SemanticParserState): SemanticParserState = {
    val filled = state.unfilledHoleIds.head
    val currentScope = filled.scope
    val (nextScope, varNames) = currentScope.extend(args)
    
    val expr = Expression2.lambda(varNames.asJava, Expression2.constant("TEMP"))

    val hole = StaticAnalysis.getLambdaBodyIndex(expr, 0)
    val holeId = state.nextId

    val part = ExpressionPart(expr, Array(hole), Array(holeId))
    
    state.fill(filled, part, List(Hole(holeId, body, nextScope, false)), this)
  }

  override def matches(expIndex: Int, exp: Expression2, typeMap: Map[Integer, Type]): Boolean = {
    if (StaticAnalysis.isLambda(exp, expIndex)) {
      val subexpArgIndexes = StaticAnalysis.getLambdaArgumentIndexes(exp, expIndex).toList
      val subexpBodyIndex = StaticAnalysis.getLambdaBodyIndex(exp, expIndex)

      subexpArgIndexes.map(typeMap(_)).equals(args) && typeMap(subexpBodyIndex).equals(body)
    } else {
      false
    }
  }
  
  override def toString(): String = {
    root + " -> (lambda (" + args.zipWithIndex.map(x => "$" + x._2 + ":" + x._1).mkString(" ") +
      ") " +  body + ")"
  }
}